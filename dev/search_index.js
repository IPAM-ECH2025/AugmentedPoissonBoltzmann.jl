var documenterSearchIndex = {"docs":
[{"location":"cells/#Electrochemical-cells","page":"Cells API","title":"Electrochemical cells","text":"","category":"section"},{"location":"cells/#Cell-Types","page":"Cells API","title":"Cell Types","text":"","category":"section"},{"location":"cells/#Abstract-Types","page":"Cells API","title":"Abstract Types","text":"","category":"section"},{"location":"cells/#Concrete-Cell-Types","page":"Cells API","title":"Concrete Cell Types","text":"","category":"section"},{"location":"cells/#Cell-Constructors","page":"Cells API","title":"Cell Constructors","text":"","category":"section"},{"location":"cells/#Solving-and-Initialization","page":"Cells API","title":"Solving and Initialization","text":"","category":"section"},{"location":"cells/#Helper-Functions","page":"Cells API","title":"Helper Functions","text":"","category":"section"},{"location":"cells/#Data-Access","page":"Cells API","title":"Data Access","text":"","category":"section"},{"location":"cells/#Calculation-Functions","page":"Cells API","title":"Calculation Functions","text":"","category":"section"},{"location":"cells/#Getter-Functions","page":"Cells API","title":"Getter Functions","text":"","category":"section"},{"location":"cells/#Setter-Functions","page":"Cells API","title":"Setter Functions","text":"","category":"section"},{"location":"cells/#Analysis-Functions","page":"Cells API","title":"Analysis Functions","text":"","category":"section"},{"location":"cells/#Boundary-Conditions-(Internal)","page":"Cells API","title":"Boundary Conditions (Internal)","text":"","category":"section"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.AbstractAugmentedPBCell","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.AbstractAugmentedPBCell","text":"AbstractAugmentedPBCell\n\nAbstract base type for all modified Poisson-Boltzmann cell types. Provides a common interface for different cell configurations.\n\n\n\n\n\n","category":"type"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.AbstractHalfCell","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.AbstractHalfCell","text":"AbstractHalfCell <: AbstractAugmentedPBCell\n\nAbstract type for half-cell configurations where only one electrode is modeled.\n\n\n\n\n\n","category":"type"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.AbstractSymmetricCell","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.AbstractSymmetricCell","text":"AbstractSymmetricCell <: AbstractAugmentedPBCell\n\nAbstract type for symmetric cell configurations with two identical electrodes.\n\n\n\n\n\n","category":"type"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.AppliedPotentialHalfCell","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.AppliedPotentialHalfCell","text":"AppliedPotentialHalfCell <: AbstractHalfCell\n\nHalf-cell configuration with applied potential boundary condition.\n\nFields\n\nsys::VoronoiFVM.System: The finite volume system containing the discretization and physics\n\nThis cell type is used for simulations where the electrode potential is controlled (potentiostatic conditions). The potential is applied at one boundary while the other boundary is typically grounded.\n\n\n\n\n\n","category":"type"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.AppliedPotentialSymmetricCell","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.AppliedPotentialSymmetricCell","text":"AppliedPotentialSymmetricCell <: AbstractAugmentedPBCell\n\nSymmetric cell configuration with applied potential.\n\nFields\n\nsys::VoronoiFVM.System: The finite volume system containing the discretization and physics\n\nThis cell type represents a symmetric configuration where both electrodes are identical and a potential is applied across them.\n\n\n\n\n\n","category":"type"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.SurfaceChargedHalfCell","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.SurfaceChargedHalfCell","text":"SurfaceChargedHalfCell <: AbstractHalfCell\n\nHalf-cell configuration with surface charge boundary condition.\n\nFields\n\nsys::VoronoiFVM.System: The finite volume system containing the discretization and physics\n\nThis cell type is used for simulations where the electrode surface charge is specified rather than the potential.\n\n\n\n\n\n","category":"type"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.SurfaceChargedSymmetricCell","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.SurfaceChargedSymmetricCell","text":"SurfaceChargedSymmetricCell <: AbstractSymmetricCell\n\nSymmetric cell configuration with surface charge boundary conditions.\n\nFields\n\nsys::VoronoiFVM.System: The finite volume system containing the discretization and physics\n\nThis cell type represents a symmetric configuration where surface charges are specified at both electrodes. Ion conservation is enforced in this configuration.\n\n\n\n\n\n","category":"type"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.AppliedPotentialHalfCell-Tuple{Any, Any}","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.AppliedPotentialHalfCell","text":"AppliedPotentialHalfCell(grid, data; dielectric_decrement=false, valuetype=Float64)\n\nCreate a half-cell with applied potential boundary conditions.\n\nArguments\n\ngrid: Computational grid\ndata::AugmentedPBData: Problem data containing physical parameters\n\nKeyword Arguments\n\ndielectric_decrement::Bool: Enable field-dependent dielectric decrement model (default: false)\nvaluetype::Type: Floating point type for calculations (default: Float64)\n\nReturns\n\nAppliedPotentialHalfCell: Cell object ready for solving\n\nFeatures\n\nIon conservation is disabled\nDense matrix storage for efficiency in small systems\nSuitable for potentiostatic simulations\nBoundary conditions: applied potential at one electrode, grounded at the other\n\nExample\n\ndata = AugmentedPBData(z=[-1, 1], q=[0.0, 0.0])\nset_molarity!(data, 0.1)\ngrid = simplexgrid(0:0.01:1)\ncell = AppliedPotentialHalfCell(grid, data)\nset_φ!(cell, 0.5)  # Apply 0.5 V\nsol = solve(cell)\n\n\n\n\n\n","category":"method"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.SurfaceChargedSymmetricCell-Tuple{Any, Any}","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.SurfaceChargedSymmetricCell","text":"SurfaceChargedSymmetricCell(grid, data; dielectric_decrement=false, valuetype=Float64)\n\nCreate a symmetric cell with surface charge boundary conditions and ion conservation.\n\nArguments\n\ngrid: Computational grid (should have a boundary region at the center)\ndata::AugmentedPBData: Problem data containing physical parameters\n\nKeyword Arguments\n\ndielectric_decrement::Bool: Enable field-dependent dielectric decrement model (default: false)\nvaluetype::Type: Floating point type for calculations (default: Float64)\n\nReturns\n\nSurfaceChargedSymmetricCell: Cell object ready for solving\n\nFeatures\n\nBoundary conditions: specified surface charges at both electrodes\nIon conservation is enabled\nSparse matrix storage  of solution in ion-conserving systems\nSymmetric configuration with identical electrodes\n\nGrid Requirements\n\nThe grid must have three boundary regions:\n\nRegion 1: Left electrode\nRegion 2: Right electrode  \nRegion 3: Center point (for pressure uniqueness and ion conservation constraints)\n\nExample\n\ndata = AugmentedPBData(z=[-1, 1], q=[0.16, -0.16])\nset_molarity!(data, 0.1)\nX = range(0, 1e-9, length=21)\ngrid = simplexgrid(X)\nbfacemask!(grid, [5e-10], [5e-10], 3)  # Mark center\ncell = SurfaceChargedSymmetricCell(grid, data)\nsol = solve(cell)\n\n\n\n\n\n","category":"method"},{"location":"cells/#VoronoiFVM.unknowns-Tuple{AbstractAugmentedPBCell}","page":"Cells API","title":"VoronoiFVM.unknowns","text":"VoronoiFVM.unknowns(cell::AbstractAugmentedPBCell)\n\nInitialize and return the unknown vector for a given cell.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nInitial unknown vector with appropriate structure and values\n\nThe unknowns include:\n\nIon mole fractions (y_α for α = 1,...,N)\nSolvent mole fraction (y_0)\nElectric potential (φ)\nPressure (p)\nElectric field strength (E)\nFor ion-conserving cells: bulk ion concentrations at the domain center\n\nInitial values are set to reasonable defaults (mole fractions ≈ 0.1 for ions, adjusted for solvent to maintain sum = 1).\n\n\n\n\n\n","category":"method"},{"location":"cells/#CommonSolve.solve-Tuple{AbstractAugmentedPBCell}","page":"Cells API","title":"CommonSolve.solve","text":"SciMLBase.solve(cell::AbstractAugmentedPBCell; inival=unknowns(cell), verbose=\"\", damp_initial=0.1, kwargs...)\n\nSolve the modified Poisson-Boltzmann system for the given cell configuration.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration to solve\n\nKeyword Arguments\n\ninival: Initial values for the unknowns (default: unknowns(cell))\nverbose::String: Verbosity level (\"\", \"n\" for newton info, etc.)\ndamp_initial::Float64: Initial damping parameter for Newton solver (default: 0.1)\nkwargs...: Additional arguments passed to the VoronoiFVM solver\n\nReturns\n\nSolution object containing the computed unknowns at all grid nodes\n\nUses a damped Newton method to solve the nonlinear system of equations.\n\n\n\n\n\n","category":"method"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.apbdata","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.apbdata","text":"apbdata(cell::AbstractAugmentedPBCell)\n\nExtract the AugmentedPBData structure from a cell.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nAugmentedPBData: The data structure containing physical parameters\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.calc_cmol-Tuple{Any, AbstractAugmentedPBCell}","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_cmol","text":"calc_cmol(sol, cell::AbstractAugmentedPBCell)\n\nCalculate ion concentrations in mol/L from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nMatrix of ion concentrations in mol/L (one row per species, one column per node)\n\n\n\n\n\n","category":"method"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.calc_c0mol-Tuple{Any, AbstractAugmentedPBCell}","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_c0mol","text":"calc_c0mol(sol, cell::AbstractAugmentedPBCell)\n\nCalculate solvent concentration in mol/L from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nVector of solvent concentrations in mol/L (one value per node)\n\n\n\n\n\n","category":"method"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.calc_χ-Tuple{Any, AbstractAugmentedPBCell}","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_χ","text":"calc_χ(sol, cell::AbstractAugmentedPBCell)\n\nCalculate electric susceptibility from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nVector of susceptibility values (one value per node)\n\n\n\n\n\n","category":"method"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.get_E","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.get_E","text":"get_E(sol, cell::AbstractAugmentedPBCell)\n\nExtract electric field strength from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nVector of electric field strengths in V/m (one value per node)\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.get_φ","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.get_φ","text":"get_φ(sol, cell::AbstractAugmentedPBCell)\n\nExtract electric potential from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nVector of electric potentials in V (one value per node)\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.get_p","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.get_p","text":"get_p(sol, cell::AbstractAugmentedPBCell)\n\nExtract pressure from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nVector of pressures in Pa (one value per node)\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.set_κ!","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.set_κ!","text":"set_κ!(cell::AbstractAugmentedPBCell, κ::Number)\n\nSet the ion solvation number for all ionic species.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\nκ::Number: Solvation number (number of solvent molecules per ion)\n\nThis sets the same solvation number for all ions in the system.\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.set_molarity!-Tuple{AbstractAugmentedPBCell, Any}","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.set_molarity!","text":"set_molarity!(cell::AbstractAugmentedPBCell, M)\n\nSet the bulk electrolyte molarity.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\nM: Molarity in mol/L\n\nUpdates the bulk ion concentrations and related parameters in the cell data.\n\n\n\n\n\n","category":"method"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.set_φ!","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.set_φ!","text":"set_φ!(cell::AbstractAugmentedPBCell, φ::Number)\n\nSet the applied electrode potential.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\nφ::Number: Applied potential in V\n\nRelevant for applied potential boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.set_q!","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.set_q!","text":"set_q!(cell::AbstractAugmentedPBCell, q::Number)\n\nSet the surface charge at the electrodes.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\nq::Number: Surface charge density in C/m²\n\nSets symmetric charges: +q at one electrode and -q at the other. Relevant for surface charge boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.dlcapsweep","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.dlcapsweep","text":"dlcapsweep(cell::AppliedPotentialHalfCell; φ_max=1.0, δφ=1.0e-5, steps=51, damp_initial=1, kwargs...)\n\nSweep electrode potential and calculate differential capacitance of the double layer.\n\nArguments\n\ncell::AppliedPotentialHalfCell: Half-cell with applied potential\n\nKeyword Arguments\n\nφ_max::Float64: Maximum absolute potential in V (default: 1.0)\nδφ::Float64: Small potential increment for numerical derivative (default: 1.0e-5)\nsteps::Int: Number of steps in the sweep (default: 51)\ndamp_initial::Float64: Initial damping for Newton solver (default: 1)\nkwargs...: Additional arguments passed to the solver\n\nReturns\n\nvolts::Vector: Applied potentials in V\ndlcaps::Vector: Differential double layer capacitances in F/m²\n\nMethod\n\nThe differential capacitance is calculated as:\n\nC_dl = fracdQdφ  fracQ(φ + δφ) - Q(φ)δφ\n\nThe sweep proceeds from φ = 0 to φ_max in both positive and negative directions, using parameter continuation for robustness.\n\nExample\n\ncell = AppliedPotentialHalfCell(grid, data)\nvolts, caps = dlcapsweep(cell, φ_max=0.5, steps=101)\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.halfcell_applied_potential_bcondition!","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.halfcell_applied_potential_bcondition!","text":"halfcell_applied_potential_bcondition!(y, u, bnode, data)\n\nBoundary condition callback for half-cell with applied potential.\n\nArguments\n\ny: Boundary residual vector\nu: Solution values at the boundary node\nbnode: Boundary node information\ndata::AugmentedPBData: Problem data\n\nApplies:\n\nDirichlet condition for φ at region 1 (working electrode): φ = data.φ\nDirichlet condition for φ at region 2 (reference): φ = 0\nDirichlet condition for pressure at region 2: p = 0\n\n\n\n\n\n","category":"function"},{"location":"cells/#AugmentedPoissonBoltzmann.SolverCore.symmcell_surfacecharge_bcondition!","page":"Cells API","title":"AugmentedPoissonBoltzmann.SolverCore.symmcell_surfacecharge_bcondition!","text":"symmcell_surfacecharge_bcondition!(y, u, bnode, data)\n\nBoundary condition callback for symmetric cell with surface charge.\n\nArguments\n\ny: Boundary residual vector\nu: Solution values at the boundary node\nbnode: Boundary node information\ndata::AugmentedPBData: Problem data\n\nApplies:\n\nNeumann condition for φ at region 1 (left electrode): -∇φ·n = q[1]\nNeumann condition for φ at region 2 (right electrode): -∇φ·n = q[2]\nDirichlet condition for pressure at region 3 (center): p = 0\n\nThe pressure condition at the domain center ensures uniqueness of the pressure solution.\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPBSystem","page":"SolverCore API","title":"AugmentedPBSystem","text":"","category":"section"},{"location":"solvercore/#AugementedPBData","page":"SolverCore API","title":"AugementedPBData","text":"","category":"section"},{"location":"solvercore/#Internal:-Constitutive-model","page":"SolverCore API","title":"Internal: Constitutive model","text":"","category":"section"},{"location":"solvercore/#Internal:-System","page":"SolverCore API","title":"Internal: System","text":"","category":"section"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.AugmentedPBSystem","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.AugmentedPBSystem","text":" AugmentedPBSystem(grid, data)\n\nCreate MPB system with pressure. Ion conserving if data.conserveions==true. In that case, the solution is a sparse matrix.\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#VoronoiFVM.unknowns","page":"SolverCore API","title":"VoronoiFVM.unknowns","text":" unknowns(sys, data)\n\nInitialize and return unknown vector.\n\n\n\n\n\nVoronoiFVM.unknowns(cell::AbstractAugmentedPBCell)\n\nInitialize and return the unknown vector for a given cell.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nInitial unknown vector with appropriate structure and values\n\nThe unknowns include:\n\nIon mole fractions (y_α for α = 1,...,N)\nSolvent mole fraction (y_0)\nElectric potential (φ)\nPressure (p)\nElectric field strength (E)\nFor ion-conserving cells: bulk ion concentrations at the domain center\n\nInitial values are set to reasonable defaults (mole fractions ≈ 0.1 for ions, adjusted for solvent to maintain sum = 1).\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.calc_cnum","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_cnum","text":" calc_cnum(sol,sys)\n\nObtain ion number densities from system\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.calc_c0num","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_c0num","text":" calc_c0num(sol,sys)\n\nObtain solvent number density from system\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.calc_cmol","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_cmol","text":" calc_cmol(sol,sys)\n\nObtain ion  molarities (molar densities in mol/L)  from system\n\n\n\n\n\ncalc_cmol(sol, cell::AbstractAugmentedPBCell)\n\nCalculate ion concentrations in mol/L from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nMatrix of ion concentrations in mol/L (one row per species, one column per node)\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.calc_c0mol","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_c0mol","text":" calc_c0mol(sol,sys)\n\nObtain solvent  molarity (molar density in mol/L)  from system\n\n\n\n\n\ncalc_c0mol(sol, cell::AbstractAugmentedPBCell)\n\nCalculate solvent concentration in mol/L from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nVector of solvent concentrations in mol/L (one value per node)\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.calc_χ","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_χ","text":" calc_χ(sol,sys)\n\n\n\n\n\ncalc_χ(sol, cell::AbstractAugmentedPBCell)\n\nCalculate electric susceptibility from the solution.\n\nArguments\n\nsol: Solution vector from the solver\ncell::AbstractAugmentedPBCell: The cell configuration\n\nReturns\n\nVector of susceptibility values (one value per node)\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.calc_spacecharge","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.calc_spacecharge","text":"calc_spacecharge(sys, sol)\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.ysum-Tuple{VoronoiFVM.System, Any}","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.ysum","text":" ysum(sys,sol)\n\n\n\n\n\n","category":"method"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.qsweep","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.qsweep","text":"qsweep(sys)\n\nSweep over series of surface charges and calculate resulting potential difference.\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.AugmentedPBData","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.AugmentedPBData","text":"struct AugmentedPBData\n\nData structure containing data for equilibrium calculations. All data including molarity in SI basic units\n\nz::Vector{Int64}: Ion charge numbers.\nN::Int64: Number of ionic species\nκ::Vector{Float64}: Ion solvation numbers\nmolarity::Float64: Bulk molarity transformed to number density\nn_E::Vector{Float64}: Bulk ion number densities\nn_avg::Vector{Float64}: Average ion number densities\nq::Vector{Float64}: Surface charges\nφ::Float64: Applied potential\nn0_ref::Float64: Solvent molarity\nv0::Float64: Solvent molecular volume\nvu::Vector{Float64}: Unsolvated ion molecular volume\nχ0::Float64: Dielectric susceptibility of solvent\nχ::Any: Dielectric susceptibility\nχvar::Bool: Dielectric susceptibility model flag\ni0::Int64: Solvent molar fraction index\niφ::Int64: Electric potential species index\nip::Int64: Pressure species index\niE::Int64: Field strength species index\ncoffset::Int64: Offset of n_E in species list\np_ref::Float64: Reference pressure\npscale::Float64: Pressure scaling nparameter\ncscale::Float64: Concentration scaling parameter\nqscale::Float64: Charge scaling parameter\nEscale::Float64: Electric field scaling parameter\nE_ref::Float64: Reference voltage\nT::Float64: Temperature\nδ0::Any: Variable susceptibility parameter for solvent\nδ::Any: Variable susceptibility parameters\nkT::Float64: Temperature times Boltzmann constant\ne::Float64: Electron charge\nε_0::Float64: Vacuum permittivity\nconserveions::Bool: Ion conservation flag\nnv::Vector{Float64}: node volumes\n\n\n\n\n\n","category":"type"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.apply_voltage!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.apply_voltage!","text":"apply_voltage!(data, v)\n\nSet working electrode voltage\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.apply_charge!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.apply_charge!","text":"apply_charge!(data,q)\n\nSet surface charge in data\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.set_molarity!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.set_molarity!","text":"set_molarity!(data,M)\n\nSet the molarity of the electrolyte and update depending data\n\n\n\n\n\nset_molarity!(cell::AbstractAugmentedPBCell, M)\n\nSet the bulk electrolyte molarity.\n\nArguments\n\ncell::AbstractAugmentedPBCell: The cell configuration\nM: Molarity in mol/L\n\nUpdates the bulk ion concentrations and related parameters in the cell data.\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.L_Debye","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.L_Debye","text":"   L_Debye(data)\n\nL_Debye=sqrt frac(1+χ)ε_0k_BTe^2n_E\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.dlcap0","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.dlcap0","text":"dlcap0(data)\n\nDouble layer capacitance at φ=0\n\nC_dl0=sqrtfrac2(1+χ) ε_0e^2 n_Ek_BT\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.capscalc","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.capscalc","text":" capscalc(sys, molarities)\n\nCalculate double layer capacitances using qsweep results.\n\nThis provides an  \"inverse\" method to calculate these capacitances. Usually one calculates charges dependent on voltages, here we calculate voltages dependent on charges.\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.DerivedData","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.DerivedData","text":"struct DerivedData\n\nStruct holding some derived data\n\nv::Vector{Float64}: Effective ion volumes\ny_E::Vector: Bulk ion mole fractions\ny0_E::Any: Bulk solvent mole fraction\n\n\n\n\n\n","category":"type"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.DerivedData-Tuple{AugmentedPBData}","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.DerivedData","text":"DerivedData(augmentedpbdata)\n\nCalculate bulk mole fractions from incompressibiltiy\n\n\n\n\n\n","category":"method"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.DerivedData-Tuple{AugmentedPBData, Any}","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.DerivedData","text":"DerivedData(augmentedpbdata, n_E)\n\nCalculate bulk mole fractions from incompressibiltiy:\n\nbeginaligned\nsumlimits_αv_αn_α^E=1\nn_0^E=frac1v_0left(1-limits_α0v_αn_α^Eright)\nn^E=frac1v_0left(1-limits_α0v_αn_α^Eright)+ limits_α0n_α^E\n   =frac1v_0left(1-limits_α0(v_α-v_0)n_α^Eright)\n   =frac1v_0left(1-limits_α0((1+ κ_α)v_0-v_0)n_α^Eright)\n   =frac1v_0left(1-limits_α0κ_αv_0n_α^Eright)\n   =frac1v_0-limits_α0κ_αn_α^E\ny_α^E=fracn_α^En^E\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.makeδ","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.makeδ","text":"makeδ(v, χ, T)\n\nCalculate δ parameter for susceptibility models\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.W","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.W","text":"W(x)\n\nW(x)= 3fracmathcal L(x)x= fraccoth(x)-frac1xx\n\nmathcal L(x) is called Langevin function.\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.Λ","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.Λ","text":" Λ(x)\n\nLambda(x)=lnleft( fracsinh(x)x  right) This is the antiderivative of the Langevin function mathcal L(x).\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.y_α","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.y_α","text":"y_α(φ,p,E,α,data, ddata)\n\nIon molar fractions\n\nEquilibrium expression for mole fractions (α0) (16)\n\ny_α(φp E)=y_α^Eexpleft(frac-z_αek_BT(φ- φ^E)-fracv_αk_BT(p-p^E) +  Lambdaleft(fracdelta_alpha Ek_BTright)right)\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.y0","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.y0","text":"y0(p, E, data, ddata)\n\nSolvent molar fraction\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.ysum-Tuple{Any, AugmentedPBData}","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.ysum","text":"ysum(u, data)\n\n\n\n\n\n","category":"method"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.spacecharge","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.spacecharge","text":"spacecharge(u, data)\n\nSolvated ion volumes:\n\nbeginaligned\nq(φp)=elimits_α z_αn_α = nelimits_α z_αy_α\n      =efraclimits_α z_αy_α(phip)limits_α v_α y_α(phip)\n   v_α=v^u_α+κ_αv_0\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.susceptibility","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.susceptibility","text":"susceptibility(u, data)\n\nSusceptibility model\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.c_num!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.c_num!","text":"c_num!(c,φ,p, data)\n\nCalculate number concentrations at discretization node\n\nbeginaligned\n\tn=sum_i=0^N y_α v_α\n\tn_α=ny_α\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.c0_num","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.c0_num","text":"c0_num(c,φ,p, data)\n\nCalculate number concentration of solvent at discretization node\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.reaction!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.reaction!","text":"reaction!(f,u,node, data)\n\nCallback which runs in every grid point.\n\nCalculate space charge density and add this to the poisson equation\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.poisson_and_p_flux!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.poisson_and_p_flux!","text":"poisson_and_p_flux!(f, u, edge, data)\n\nRuns on every grid edge. Calculate fluxes for the Poisson and the pressure equations.\n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.bcondition!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.bcondition!","text":"bcondition!(y, u, bnode, data)\n\nBoundary condition callback. The Dirichlet condition for the pressure in the mid of the domain ensures uniqueness of the pressure equation. \n\n\n\n\n\n","category":"function"},{"location":"solvercore/#AugmentedPoissonBoltzmann.SolverCore.ionconservation!","page":"SolverCore API","title":"AugmentedPoissonBoltzmann.SolverCore.ionconservation!","text":" ionconservation!(f, u, sys, data)\n\n\"Generic callback\" which shall ensure the ion conservation constraint. This method runs over the full grid, and its sparsity pattern is automatically detected. It is called if ion conservation is required. In this case, n^E_lpha are additional unknowns scaled by cscale (default: N_A) which are attached to the mid of the domain (node i3), and additional equations need to be assembled. These are N-1 ion conservation constraints and the an electroneutrality constraint.\n\n\n\n\n\n","category":"function"},{"location":"#AugmentedPoissonBoltzmann","page":"Home","title":"AugmentedPoissonBoltzmann","text":"AugmentedPoissonBoltzmann\n\nPoisson-Boltzmann solver with finite ion sizes, solvation, dielectric decrement and ion conservation.\n\nDevelopment initiated during the IPAM Long Program - Bridging the Gap: Transitioning from Deterministic to Stochastic Interaction Modeling in Electrochemistry\n\n\n\n\n\n","category":"module"},{"location":"helpers/#AugmentedPoissonBoltzmann.SolverCore.pramp","page":"Helpers","title":"AugmentedPoissonBoltzmann.SolverCore.pramp","text":" pramp(\n    f;\n    p = [0, 1],\n    hmin = (p[end] - p[begin]) / 1000,\n    hmax = (p[end] - p[begin]) / 10,\n    h = hmax,\n    hgrow = 1.2,\n    hdegrow = 0.5,\n    verbose = false\n)\n\nRun 'f(p)'  successively with parameter values from the range given by 'p'. Stepsize is given by h. If f throws an error, solution is retried with a lower value of h, otherwise, h is increased unless it exceeded hmax.\n\n\n\n\n\n","category":"function"},{"location":"pyapi/#Python-Access","page":"Python Access","title":"Python Access","text":"","category":"section"},{"location":"pyapi/#Internal","page":"Python Access","title":"Internal","text":"","category":"section"},{"location":"pyapi/#AugmentedPoissonBoltzmann.mpbpsolve","page":"Python Access","title":"AugmentedPoissonBoltzmann.mpbpsolve","text":"mpbpsolve(; n=21, \n            chargenumbers=[-1, 1], \n            domain=[0, 1.0e-10], \n            surfacecharge=[0.16, -0.16], \n            bulkmolarity=0.1)\n\nSolve the modified Poisson-Boltzmann problem with specified bulk molarity.\n\nThis function solves the modified Poisson-Boltzmann equation for a 1D domain with specified surface charges and bulk ion concentrations. The solver uses a finite volume method with ExtendableGrids and VoronoiFVM.\n\nArguments\n\nn::Int=21: Number of grid points along the domain. Default is 21.\nchargenumbers::Vector{Int}=[-1, 1]: Charge numbers of the ionic species (e.g., [-1, 1] for monovalent anions and cations).\ndomain::Vector{Float64}=[0, 1.0e-10]: Domain boundaries in meters [start, end]. Default is [0, 1.0e-10] (0 to 0.1 nm).\nsurfacecharge::Vector{Float64}=[0.16, -0.16]: Surface charge densities at the domain boundaries in C/m².\nbulkmolarity::Float64=0.1: Bulk molarity of the electrolyte solution in mol/L.\n\nReturns\n\nX: Grid coordinates in m (Vector{Float64})\nc0: Solvent concentration in mol/L  (Vector{Float64})\nc1: Concentration of first ionic species along the grid  in mol/L (Vector{Float64})\nc2: Concentration of second ionic species along the grid  in mol/L(Vector{Float64})\n\nExamples\n\n# Solve with default parameters\nX, c0, c_anion, c_cation = mpbpsolve()\n\n# Solve with custom parameters\nX, c0, c_anion, c_cation = mpbpsolve(\n    n=51,\n    chargenumbers=[-1, 1],\n    domain=[0, 2.0e-10],\n    surfacecharge=[0.2, -0.2],\n    bulkmolarity=0.15\n)\n\nNotes\n\nThe function automatically creates a uniform grid over the specified domain\nA boundary face mask is applied at the domain midpoint in order fix the pressure value there\nThe solver uses damped Newton iteration with initial damping factor of 0.05\nSurface charges should be specified in SI units (C/m²)\nDomain should be specified in SI units (meters)\n\n\n\n\n\n","category":"function"},{"location":"pyapi/#AugmentedPoissonBoltzmann.icmpbpsolve","page":"Python Access","title":"AugmentedPoissonBoltzmann.icmpbpsolve","text":"icmpbpsolve(; n=21, \n              chargenumbers=[-1, 1], \n              domain=[0, 1.0e-10], \n              surfacecharge=[0.16, -0.16], \n              averagemolarity=1)\n\nSolve the ion-conserving modified Poisson-Boltzmann problem with specified average molarity.\n\nThis function solves the modified Poisson-Boltzmann equation with ion conservation constraints. Unlike mpbpsolve, this solver conserves the total number of ions in the system and uses an average molarity parameter rather than bulk molarity. This is particularly useful for systems where ion conservation is physically important.\n\nArguments\n\nn::Int=21: Number of grid points along the domain. Must be odd (automatically incremented if even). Default is 21.\nchargenumbers::Vector{Int}=[-1, 1]: Charge numbers of the ionic species (e.g., [-1, 1] for monovalent anions and cations).\ndomain::Vector{Float64}=[0, 1.0e-10]: Domain boundaries in meters [start, end]. Default is [0, 1.0e-10] (0 to 0.1 nm).\nsurfacecharge::Vector{Float64}=[0.16, -0.16]: Surface charge densities at the domain boundaries in C/m².\naveragemolarity::Float64=1: Average molarity of the electrolyte solution in mol/L.\n\nReturns\n\nX: Grid coordinates in m (Vector{Float64})\nc0: Solvent concentration in mol/L  (Vector{Float64})\nc1: Concentration of first ionic species along the grid in mol/L (Vector{Float64})\nc2: Concentration of second ionic species along the grid in mol/L (Vector{Float64})\n\nExamples\n\n# Solve with default parameters\nX, c0, c_anion, c_cation = icmpbpsolve()\n\n# Solve with custom parameters and higher resolution\nX, c0, c_anion, c_cation = icmpbpsolve(\n    n=101,\n    chargenumbers=[-2, 1],  # divalent anions, monovalent cations\n    domain=[0, 5.0e-10],\n    surfacecharge=[0.3, -0.3],\n    averagemolarity=0.5\n)\n\nNotes\n\nThe function enforces an odd number of grid points for numerical stability\nIon conservation is enforced through the conserveions=true parameter in AugmentedPBData\nThe solver employs damped Newton iteration with initial damping factor of 0.05\nAverage molarity represents the spatial average concentration, which may differ from bulk concentration due to ion conservation\nSurface charges should be specified in SI units (C/m²)\nDomain should be specified in SI units (meters)\n\nDifferences from mpbpsolve\n\nEnforces ion conservation constraints\nUses average rather than bulk molarity\nRequires odd number of grid points\nMay show different concentration profiles due to conservation effects\n\n\n\n\n\n","category":"function"},{"location":"pyapi/#AugmentedPoissonBoltzmann.prepare_grid","page":"Python Access","title":"AugmentedPoissonBoltzmann.prepare_grid","text":"prepare_grid(n, domain)\n\nPrepare eqidistant simulation grid. Add  interface region in the mid of the domain in order to fix pressure and provide location for ion conservation constraints.\n\n\n\n\n\n","category":"function"}]
}
